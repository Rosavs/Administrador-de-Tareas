# -*- coding: utf-8 -*-
"""administrador_de_tareas_conectado.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17R84W4FMYo4ZX8qMylzgMfUl_hRLu7-3
"""

import sqlite3

class Tarea():
    def __init__(self,nombre,numerotareas):
        self.nombre = nombre
        self.numerotareas = numerotareas
        # self.estado = [] # Estas líneas las comentaremos o eliminaremos después
        # self.tareas = [] # porque la base de datos manejará el almacenamiento

        # Conecta a la base de datos (se crea si no existe)
        self.conn = sqlite3.connect('tareas.db')
        self.cursor = self.conn.cursor()

        # Crea la tabla tareas si no existe
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS tareas (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                descripcion TEXT NOT NULL,
                estado TEXT NOT NULL
            )
        ''')
        self.conn.commit()

        # Carga tareas existentes desde la base de datos
        self.tareas = [] # Inicializamos la lista para almacenar las descripciones
        self.estado = [] # Inicializamos la lista para almacenar los estados
        self.cursor.execute("SELECT descripcion, estado FROM tareas")
        filas = self.cursor.fetchall()
        for fila in filas:
            self.tareas.append(fila[0])
            self.estado.append(fila[1])

        # Si no hay tareas existentes, pedimos la primera tarea (modificado)
        if not self.tareas:
            primera_tarea = input("Primera tarea: ")
            self.tareas.append(primera_tarea)
            self.estado.append("pendiente")
            # Guarda la primera tarea en la base de datos
            self.cursor.execute("INSERT INTO tareas (descripcion, estado) VALUES (?, ?)", (primera_tarea, "pendiente"))
            self.conn.commit()

        # self.tareas.append(input("Primera tarea: ")) # Eliminamos esta línea del código original
        # self.estado.append("pendiente") # Eliminamos esta línea del código original

        self.opciones()

        # Añade una tarea si el número máximo no ha sido alcanzado
        # Añade "pendiente" a la lista de estados porque una tarea nueva siempre empezará como pendiente
        # Inserta la nueva tarea en la base de datos
        # y vuelve a mostrar las opciones

        def añadir(self):
            if len(self.tareas) < self.numerotareas:
                nueva_tarea_descripcion = input("Nueva tarea: ")
                self.tareas.append(nueva_tarea_descripcion)
                self.estado.append("pendiente")

                # Insertar la nueva tarea en la base de datos
                self.cursor.execute("INSERT INTO tareas (descripcion, estado) VALUES (?, ?)", (nueva_tarea_descripcion, "pendiente"))
                self.conn.commit() # Confirmar la inserción

                print("Tarea añadida.")
            else:
                print("No se pueden añadir más tareas. Límite alcanzado.")
                self.opciones() # Vuelve a mostrar las opciones después de añadir

        # Lista todas las tareas numeradas y muestra su estado
        # Consulta la base de datos para obtener las tareas
        # y vuelve a mostrar las opciones

        def listar(self):
            print("\n--- Lista de Tareas ---")
            self.cursor.execute("SELECT id, descripcion, estado FROM tareas")
            filas = self.cursor.fetchall()

            if not filas:
                print("No hay tareas en la lista.")
            else:
                for fila in filas:
                    tarea_id, descripcion, estado = fila # Desempaquetamos la tupla
                    print(f"{tarea_id}. {descripcion} - Estado: {estado}")

            print("-------------------------")
            self.opciones()

            # Pide el ID de la tarea a eliminar (usando el ID de la base de datos)
            # Comprueba si el ID existe en la base de datos
            # Si es así elimina la tarea de la base de datos
            # y actualiza las listas en memoria
            # y vuelve a mostrar las opciones

        def eliminar(self):
            try:
                # Primero, listamos las tareas para que el usuario vea los IDs
                self.listar_para_elegir() # Necesitamos una versión de listar que no muestre opciones
                id_tarea_eliminar = int(input("ID de la tarea a eliminar: "))

                # Verifica si la tarea con ese ID existe en la base de datos
                self.cursor.execute("SELECT COUNT(*) FROM tareas WHERE id = ?", (id_tarea_eliminar,))
                existe = self.cursor.fetchone()[0]

                if existe > 0:
                    # Elimina la tarea de la base de datos
                    self.cursor.execute("DELETE FROM tareas WHERE id = ?", (id_tarea_eliminar,))
                    self.conn.commit()
                    print(f"Tarea con ID {id_tarea_eliminar} eliminada.")

                    # Opcional: Volver a cargar las tareas en memoria después de eliminar
                    # Esto mantiene self.tareas y self.estado sincronizados con la DB
                    self.cargar_tareas_desde_db() # Necesitamos un método para esto

                else:
                    print("ID de tarea no válido.")
            except ValueError:
                print("Entrada no válida. Introduce un número.")
            self.opciones() # Vuelve a mostrar las opciones

        # Pide el ID de la tarea a completar (usando el ID de la base de datos)
        # Comprueba si el ID existe en la base de datos
        # Si es así cambia el estado a "completada" en la base de datos
        # y actualiza las listas en memoria
        # y vuelve a mostrar las opciones

        def completar(self):
            try:
                # Primero, listamos las tareas para que el usuario vea los IDs
                self.listar_para_elegir() # Reutilizamos este método para mostrar los IDs
                id_tarea_completar = int(input("ID de la tarea a completar: "))

                # Verificar si la tarea con ese ID existe en la base de datos
                self.cursor.execute("SELECT COUNT(*) FROM tareas WHERE id = ?", (id_tarea_completar,))
                existe = self.cursor.fetchone()[0]

                if existe > 0:
                    # Actualizar el estado en la base de datos
                    self.cursor.execute("UPDATE tareas SET estado = ? WHERE id = ?", ("completada", id_tarea_completar))
                    self.conn.commit()
                    print(f"Tarea con ID {id_tarea_completar} marcada como completada.")

                    # Opcional: Volver a cargar las tareas en memoria después de actualizar
                    elf.cargar_tareas_desde_db()

                else:
                    print("ID de tarea no válido.")
            except ValueError:
                print("Entrada no válida. Introduce un número.")
            self.opciones() # Vuelve a mostrar las opciones

"""¡Claro! Aquí tienes el código completo de la clase `Tarea` con todas las modificaciones que hemos realizado para integrar la base de datos:"""

import sqlite3

class Tarea():
    def __init__(self,nombre,numerotareas):
        self.nombre = nombre
        self.numerotareas = numerotareas
        # self.estado = [] # Estas líneas las comentaremos o eliminaremos después
        # self.tareas = [] # porque la base de datos manejará el almacenamiento

        # Conecta a la base de datos (se crea si no existe)
        self.conn = sqlite3.connect('tareas.db')
        self.cursor = self.conn.cursor()

        # Crea la tabla tareas si no existe
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS tareas (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                descripcion TEXT NOT NULL,
                estado TEXT NOT NULL
            )
        ''')
        self.conn.commit()

        # Carga tareas existentes desde la base de datos
        self.tareas = [] # Inicializamos la lista para almacenar las descripciones
        self.estado = [] # Inicializamos la lista para almacenar los estados
        self.cursor.execute("SELECT descripcion, estado FROM tareas")
        filas = self.cursor.fetchall()
        for fila in filas:
            self.tareas.append(fila[0])
            self.estado.append(fila[1])

        # Si no hay tareas existentes, pedimos la primera tarea (modificado)
        if not self.tareas:
            primera_tarea = input("Primera tarea: ")
            self.tareas.append(primera_tarea)
            self.estado.append("pendiente")
            # Guarda la primera tarea en la base de datos
            self.cursor.execute("INSERT INTO tareas (descripcion, estado) VALUES (?, ?)", (primera_tarea, "pendiente"))
            self.conn.commit()

        # self.tareas.append(input("Primera tarea: ")) # Eliminamos esta línea del código original
        # self.estado.append("pendiente") # Eliminamos esta línea del código original

        self.opciones()

    # muestra las diferentes opciones y pide una opción
    def opciones(self):
        print("\n--- Organizador de tareas: ",self.nombre,"---")
        print("Opciones: \n A para Agregar nueva tarea\
        \n C para Completar una tarea\
        \n L para Listar todas las tareas\
        \n E para Eliminar una tarea\
        \n S para Salir ")
        self.opcion = input("Elige una opción: ")

        # admite mayúscula o minúscula y llama a los posibles métodos
        if self.opcion in ["A","a"] :
            self.añadir()
        elif self.opcion in ["E","e"]:
            self.eliminar()
        elif self.opcion in ["L","l"]:
            self.listar()
        elif self.opcion in ["C","c"]:
            self.completar()
        elif self.opcion in ["S","s"]:
            print("¡Hasta luego!")        #si se elige la S o s termina
            self.conn.close() # Cerrar la conexión a la base de datos al salir
        #si la opción elegida no exite, vuelve a mostrar las opciones
        #llamando al método self.opciones
        else:
            print("Opción no válida")
            self.opciones()

    # Añade una tarea si el número máximo no ha sido alcanzado
    # Añade "pendiente" a la lista de estados porque una tarea nueva siempre empezará como pendiente
    # Inserta la nueva tarea en la base de datos
    # y vuelve a mostrar las opciones
    def añadir(self):
        if len(self.tareas) < self.numerotareas:
            nueva_tarea_descripcion = input("Nueva tarea: ")
            self.tareas.append(nueva_tarea_descripcion)
            self.estado.append("pendiente")

            # Insertar la nueva tarea en la base de datos
            self.cursor.execute("INSERT INTO tareas (descripcion, estado) VALUES (?, ?)", (nueva_tarea_descripcion, "pendiente"))
            self.conn.commit() # Confirmar la inserción

            print("Tarea añadida.")
        else:
            print("No se pueden añadir más tareas. Límite alcanzado.")
        self.opciones() # Vuelve a mostrar las opciones después de añadir

    # Lista todas las tareas numeradas y muestra su estado
    # Consulta la base de datos para obtener las tareas
    # y vuelve a mostrar las opciones
    def listar(self):
        print("\n--- Lista de Tareas ---")
        self.cursor.execute("SELECT id, descripcion, estado FROM tareas")
        filas = self.cursor.fetchall()

        if not filas:
            print("No hay tareas en la lista.")
        else:
            for fila in filas:
                tarea_id, descripcion, estado = fila # Desempaquetamos la tupla
                print(f"{tarea_id}. {descripcion} - Estado: {estado}")

        print("-------------------------")
        self.opciones()

    # Método auxiliar para listar tareas con IDs sin mostrar opciones después
    def listar_para_elegir(self):
        print("\n--- Lista de Tareas ---")
        self.cursor.execute("SELECT id, descripcion, estado FROM tareas")
        filas = self.cursor.fetchall()

        if not filas:
            print("No hay tareas en la lista.")
        else:
            for fila in filas:
                tarea_id, descripcion, estado = fila
                print(f"{tarea_id}. {descripcion} - Estado: {estado}")
        print("-------------------------")

    # Método auxiliar para recargar las listas en memoria desde la base de datos
    def cargar_tareas_desde_db(self):
        self.tareas = [] # Limpiamos las listas actuales
        self.estado = []
        self.cursor.execute("SELECT descripcion, estado FROM tareas")
        filas = self.cursor.fetchall()
        for fila in filas:
            self.tareas.append(fila[0])
            self.estado.append(fila[1])


    # Pide el ID de la tarea a eliminar (usando el ID de la base de datos)
    # Comprueba si el ID existe en la base de datos
    # Si es así elimina la tarea de la base de datos
    # y actualiza las listas en memoria
    # y vuelve a mostrar las opciones
    def eliminar(self):
        try:
            # Primero, listamos las tareas para que el usuario vea los IDs
            self.listar_para_elegir()
            id_tarea_eliminar = int(input("ID de la tarea a eliminar: "))

            # Verificar si la tarea con ese ID existe en la base de datos
            self.cursor.execute("SELECT COUNT(*) FROM tareas WHERE id = ?", (id_tarea_eliminar,))
            existe = self.cursor.fetchone()[0]

            if existe > 0:
                # Eliminar la tarea de la base de datos
                self.cursor.execute("DELETE FROM tareas WHERE id = ?", (id_tarea_eliminar,))
                self.conn.commit()
                print(f"Tarea con ID {id_tarea_eliminar} eliminada.")

                # Opcional: Volver a cargar las tareas en memoria después de eliminar
                self.cargar_tareas_desde_db()

            else:
                print("ID de tarea no válido.")
        except ValueError:
            print("Entrada no válida. Introduce un número.")
        self.opciones() # Vuelve a mostrar las opciones

    # Pide el ID de la tarea a completar (usando el ID de la base de datos)
    # Comprueba si el ID existe en la base de datos
    # Si es así cambia el estado a "completada" en la base de datos
    # y actualiza las listas en memoria
    # y vuelve a mostrar las opciones
    def completar(self):
        try:
            # Primero, listamos las tareas para que el usuario vea los IDs
            self.listar_para_elegir() # Reutilizamos este método para mostrar los IDs
            id_tarea_completar = int(input("ID de la tarea a completar: "))

            # Verificar si la tarea con ese ID existe en la base de datos
            self.cursor.execute("SELECT COUNT(*) FROM tareas WHERE id = ?", (id_tarea_completar,))
            existe = self.cursor.fetchone()[0]

            if existe > 0:
                # Actualizar el estado en la base de datos
                self.cursor.execute("UPDATE tareas SET estado = ? WHERE id = ?", ("completada", id_tarea_completar))
                self.conn.commit()
                print(f"Tarea con ID {id_tarea_completar} marcada como completada.")

                # Opcional: Volver a cargar las tareas en memoria después de actualizar
                self.cargar_tareas_desde_db()

            else:
                print("ID de tarea no válido.")
        except ValueError:
            print("Entrada no válida. Introduce un número.")
        self.opciones() # Vuelve a mostrar las opciones

"""Y aquí tienes el código completo juntando la clase `Tarea` y la parte principal que inicia la ejecución. Puedes copiar y pegar este código en una celda de código para probar tu administrador de tareas con base de datos."""

import sqlite3

class Tarea():
    def __init__(self,nombre,numerotareas):
        self.nombre = nombre
        self.numerotareas = numerotareas

        # Conecta a la base de datos (se crea si no existe)
        self.conn = sqlite3.connect('tareas.db')
        self.cursor = self.conn.cursor()

        # Crea la tabla tareas si no existe
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS tareas (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                descripcion TEXT NOT NULL,
                estado TEXT NOT NULL
            )
        ''')
        self.conn.commit()

        # Carga tareas existentes desde la base de datos
        self.tareas = [] # Inicializamos la lista para almacenar las descripciones
        self.estado = [] # Inicializamos la lista para almacenar los estados
        self.cursor.execute("SELECT descripcion, estado FROM tareas")
        filas = self.cursor.fetchall()
        for fila in filas:
            self.tareas.append(fila[0])
            self.estado.append(fila[1])

        # Si no hay tareas existentes, pedimos la primera tarea
        if not self.tareas:
            primera_tarea = input("Primera tarea: ")
            self.tareas.append(primera_tarea)
            self.estado.append("pendiente")
            # Guarda la primera tarea en la base de datos
            self.cursor.execute("INSERT INTO tareas (descripcion, estado) VALUES (?, ?)", (primera_tarea, "pendiente"))
            self.conn.commit()

        self.opciones()

    # Muestra las diferentes opciones y pide una opción
    def opciones(self):
        print("\n--- Organizador de tareas: ",self.nombre,"---")
        print("Opciones: \n A para Agregar nueva tarea\
        \n C para Completar una tarea\
        \n L para Listar todas las tareas\
        \n E para Eliminar una tarea\
        \n S para Salir ")
        self.opcion = input("Elige una opción: ")

        # Admite mayúscula o minúscula y llama a los posibles métodos
        if self.opcion in ["A","a"] :
            self.añadir()
        elif self.opcion in ["E","e"]:
            self.eliminar()
        elif self.opcion in ["L","l"]:
            self.listar()
        elif self.opcion in ["C","c"]:
            self.completar()
        elif self.opcion in ["S","s"]:
            print("¡Hasta luego!")        #si se elige la S o s termina
            self.conn.close() # Cerrar la conexión a la base de datos al salir
        # Si la opción elegida no exite, vuelve a mostrar las opciones
        # llamando al método self.opciones
        else:
            print("Opción no válida")
            self.opciones()

    # Añade una tarea si el número máximo no ha sido alcanzado
    # Añade "pendiente" a la lista de estados porque una tarea nueva siempre empezará como pendiente
    # Inserta la nueva tarea en la base de datos
    # y vuelve a mostrar las opciones
    def añadir(self):
        if len(self.tareas) < self.numerotareas:
            nueva_tarea_descripcion = input("Nueva tarea: ")
            self.tareas.append(nueva_tarea_descripcion)
            self.estado.append("pendiente")

            # Insertar la nueva tarea en la base de datos
            self.cursor.execute("INSERT INTO tareas (descripcion, estado) VALUES (?, ?)", (nueva_tarea_descripcion, "pendiente"))
            self.conn.commit() # Confirmar la inserción

            print("Tarea añadida.")
        else:
            print("No se pueden añadir más tareas. Límite alcanzado.")
        self.opciones() # Vuelve a mostrar las opciones después de añadir

    # Lista todas las tareas numeradas y muestra su estado
    # Consulta la base de datos para obtener las tareas
    # y vuelve a mostrar las opciones

    def listar(self):
        print("\n--- Lista de Tareas ---")
        self.cursor.execute("SELECT id, descripcion, estado FROM tareas")
        filas = self.cursor.fetchall()

        if not filas:
            print("No hay tareas en la lista.")
        else:
            for fila in filas:
                tarea_id, descripcion, estado = fila # Desempaquetamos la tupla
                print(f"{tarea_id}. {descripcion} - Estado: {estado}")

        print("-------------------------")
        self.opciones()

    # Método auxiliar para listar tareas con IDs sin mostrar opciones después
    def listar_para_elegir(self):
        print("\n--- Lista de Tareas ---")
        self.cursor.execute("SELECT id, descripcion, estado FROM tareas")
        filas = self.cursor.fetchall()

        if not filas:
            print("No hay tareas en la lista.")
        else:
            for fila in filas:
                tarea_id, descripcion, estado = fila
                print(f"{tarea_id}. {descripcion} - Estado: {estado}")
        print("-------------------------")

    # Método auxiliar para recargar las listas en memoria desde la base de datos
    def cargar_tareas_desde_db(self):
        self.tareas = [] # Limpiamos las listas actuales
        self.estado = []
        self.cursor.execute("SELECT descripcion, estado FROM tareas")
        filas = self.cursor.fetchall()
        for fila in filas:
            self.tareas.append(fila[0])
            self.estado.append(fila[1])


    # Pide el ID de la tarea a eliminar (usando el ID de la base de datos)
    # Comprueba si el ID existe en la base de datos
    # Si es así elimina la tarea de la base de datos
    # y actualiza las listas en memoria
    # y vuelve a mostrar las opciones
    def eliminar(self):
        try:
            # Primero, listamos las tareas para que el usuario vea los IDs
            self.listar_para_elegir()
            id_tarea_eliminar = int(input("ID de la tarea a eliminar: "))

            # Verificar si la tarea con ese ID existe en la base de datos
            self.cursor.execute("SELECT COUNT(*) FROM tareas WHERE id = ?", (id_tarea_eliminar,))
            existe = self.cursor.fetchone()[0]

            if existe > 0:
                # Elimina la tarea de la base de datos
                self.cursor.execute("DELETE FROM tareas WHERE id = ?", (id_tarea_eliminar,))
                self.conn.commit()
                print(f"Tarea con ID {id_tarea_eliminar} eliminada.")

                # Opcional: Volver a cargar las tareas en memoria después de eliminar
                self.cargar_tareas_desde_db()

            else:
                print("ID de tarea no válido.")
        except ValueError:
            print("Entrada no válida. Introduce un número.")
        self.opciones() # Vuelve a mostrar las opciones

    # Pide el ID de la tarea a completar (usando el ID de la base de datos)
    # Comprueba si el ID existe en la base de datos
    # Si es así cambia el estado a "completada" en la base de datos
    # y actualiza las listas en memoria
    # y vuelve a mostrar las opciones
    def completar(self):
        try:
            # Primero, listamos las tareas para que el usuario vea los IDs
            self.listar_para_elegir() # Reutilizamos este método para mostrar los IDs
            id_tarea_completar = int(input("ID de la tarea a completar: "))

            # Verificar si la tarea con ese ID existe en la base de datos
            self.cursor.execute("SELECT COUNT(*) FROM tareas WHERE id = ?", (id_tarea_completar,))
            existe = self.cursor.fetchone()[0]

            if existe > 0:
                # Actualiza el estado en la base de datos
                self.cursor.execute("UPDATE tareas SET estado = ? WHERE id = ?", ("completada", id_tarea_completar))
                self.conn.commit()
                print(f"Tarea con ID {id_tarea_completar} marcada como completada.")

                # Opcional: Volver a cargar las tareas en memoria después de actualizar
                self.cargar_tareas_desde_db()

            else:
                print("ID de tarea no válido.")
        except ValueError:
            print("Entrada no válida. Introduce un número.")
        self.opciones() # Vuelve a mostrar las opciones


# --- Parte principal del programa ---

# Aquí empieza a ejecutarse pidiendo un nombre y un número de tareas máximo para almacenar

print("¡Comenzamos!")

while True:

    a=input("Elige un nombre para el organizador: ")
    b=input("Elige un número máximo de tareas (de 1 a 10): ")

    try:
        nub=int(b)                             # si el valor introducido es un número
                                               # comprueba que está entre 0 y 10
        if 10< nub or nub <= 0:
            print("Número fuera de rango")     # si no está en el rango avisa
        elif 0< nub <=  10:
            tar=Tarea(a,nub)                   # si todo está bien se ejecuta creando un objeto de la clase Tarea
            break                              # con los parámetros introducidos
    except:
        if b.isnumeric() == False:             # si el valor introducido no es numérico
            print("Sólo numeros")              # avisa

